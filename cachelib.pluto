local { base64, buffer, crypto, ffi, http } = require "*"
local base_path <const> = io.part(debug.getinfo(1, "S").source:sub(2), "parent")

function b64m_encode(data)
	return base64.encode(data, false):replace("/", "-")
end

function b64m_decode(data)
	return base64.decode(data:replace("-", "/"))
end

function get_local_path(path, suffix = "")
	return base_path.."/data/0"..suffix..path
end

class CacheManifestReader
	function __construct(path)
		self.bin = io.contents(get_local_path(path).."_H")
		self.i = 1
		self.i += 20
		self.entry_i = 0
		self.num_entries, self.i = string.unpack("<I4", self.bin, self.i)
		if self.num_entries == 0 then
			self.num_entries, self.i = string.unpack("<I4", self.bin, self.i)
		end
		self.paths = {}
		self.hashes = {}
	end

	function getHash(target_path)
		if hash := self.hashes[target_path] then
			return hash
		end
		while self.entry_i ~= self.num_entries do
			self.entry_i += 1
			local path, hash
			path, self.i = string.unpack("<s4", self.bin, self.i)
			hash = self.bin:sub(self.i, self.i + 15)
			self.i += 20
			self.paths:insert(path)
			self.hashes[path] = hash
			if path == target_path then
				return hash
			end
		end
	end

	function getPaths()
		while self.entry_i ~= self.num_entries do
			self.entry_i += 1
			local path, hash
			path, self.i = string.unpack("<s4", self.bin, self.i)
			hash = self.bin:sub(self.i, self.i + 15)
			self.i += 20
			self.paths:insert(path)
			self.hashes[path] = hash
		end
		return self.paths
	end

	function downloadFile(path, type, suffix = "")
		local manifest_hash = self:getHash(path)
		assert(manifest_hash ~= nil, "file not in manifest")

		local header_hash
		if cont := io.contents(get_local_path(path, suffix).."_H") then
			header_hash = cont:sub(1, 16)
		end

		if manifest_hash ~= header_hash then
			download_file(path, type, b64m_encode(manifest_hash), suffix)
		end
	end
end

function oodle_init()
	if not oo2core_9_win64 then
		oo2core_9_win64 = ffi.open(base_path.."/oo2core_9_win64")
		oo2core_9_win64:cdef[[
		int OodleLZ_Decompress(const char* inputData, size_t inputLen, void* outputData, size_t outputLen, int a5, int a6, int a7, size_t a8, size_t a9, size_t a10, size_t a11, size_t a12, size_t a13, int a14);
		int OodleLZ_Compress(int format, const char* data, size_t size, void* out, int level, size_t pOptions, size_t a7, size_t a8, size_t a9);
		]]
	end
end

function oodle_decompress(compressed, decompressed_size)
	oodle_init()
	local out = ffi.alloc(decompressed_size)
	oo2core_9_win64.OodleLZ_Decompress(compressed, #compressed, out, decompressed_size, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3)
	return ffi.read(out)
end

function oodle_compress(data)
	oodle_init()
	$define format = 13 -- https://github.com/Crauzer/OodleSharp/blob/master/OodleSharp/OodleFormat.cs
	$define level = 4 -- https://github.com/Crauzer/OodleSharp/blob/master/OodleSharp/OodleCompressionLevel.cs
	local out_data = ffi.alloc(#data + 69)
	local out_size = oo2core_9_win64.OodleLZ_Compress(format, data, #data, out_data, level, 0, 0, 0, 0)
	return ffi.read(out_data):sub(1, out_size)
end

function shcc_decompress_chunk(bin, i)
	local chunk_type, decompressed_size, compressed_size
	chunk_type, i = string.unpack("<I1", bin, i)	
	decompressed_size, i = string.unpack("<I4", bin, i)
	compressed_size, i = string.unpack("<I4", bin, i)
	--[[print("chunk_type", chunk_type)
	print("compressed_size", compressed_size)
	print("decompressed_size", decompressed_size)]]
	if chunk_type == 0 then
		assert(compressed_size == decompressed_size)
		local data = bin:sub(i, i + compressed_size - 1)
		i += decompressed_size
		return data, i
	end
	assert(chunk_type == 2)
	return shcc_decompress_chunk_oodle(bin, i, decompressed_size)
end

function shcc_decompress_chunk_oodle(bin, i, decompressed_size)
	local decompressed = ""
	while #decompressed < decompressed_size do
		local block_info = bin:sub(i, i + 7)
		i += 8
		assert(block_info:byte(1) == 0x80)
		assert((block_info:byte(8) & 0x0F) == 0x01)
		local num1 = (block_info:byte(1) << 24) | (block_info:byte(2) << 16) | (block_info:byte(3) << 8) | block_info:byte(4)
		local num2 = (block_info:byte(5) << 24) | (block_info:byte(6) << 16) | (block_info:byte(7) << 8) | block_info:byte(8)
		local block_compressed_size = (num1 >> 2) & 0xFFFFFF
		local block_decompressed_size = (num2 >> 5) & 0xFFFFFF
		--[[print("block_compressed_size", block_compressed_size)
		print("block_decompressed_size", block_decompressed_size)]]
		assert(bin:byte(i) == 0x8C)
		decompressed ..= oodle_decompress(bin:sub(i, i + block_compressed_size - 1), block_decompressed_size)
		i += block_compressed_size
	end
	return decompressed, i
end

function shcc_decompress(bin)
	local i = 1
	i += 8
	local data = {}
	data.H, i = shcc_decompress_chunk(bin, i)
	try
		local B_start = i
		data.B, i = shcc_decompress_chunk(bin, i)
		data.B_compressed = bin:sub(B_start + 9, -15)
	catch _ then
	end
	return data
end

function shcc_hash(data)
	return crypto.md5("SHCC\x1F\x00\x00\x00"..data.H:sub(17)..(data.B_compressed or ""), true)
end

-- Works for H.Cache.bin so far
function shcc_pack_H(data)
	local bin = "SHCC\x1f\x00\x00\x00"
	local hash = crypto.md5("SHCC\x1f\x00\x00\x00"..data:sub(17), true)

	bin ..= "\x00"
	bin ..= string.pack("<I4I4", #data, #data)
	bin ..= hash
	bin ..= data:sub(17)

	bin ..= "\x00\xFF\xFF\xFF\xFF\x00\x00\x00\x00\x00\xFF\xFF\xFF\xFF\x00\x00\x00\x00\x52"
	bin ..= string.pack("<I4", crypto.crc32c(bin))

	return bin, hash
end

function shcc_pack_HB(H, B_compressed, B_decompressed_size)
	local bin = "SHCC\x1f\x00\x00\x00"
	local hash = shcc_hash({ H = H, B_compressed = B_compressed })

	bin ..= "\x00"
	bin ..= string.pack("<I4I4", #H, #H)
	bin ..= hash
	bin ..= H:sub(17)

	bin ..= "\x02"
	bin ..= string.pack("<I4I4", B_decompressed_size, #B_compressed)
	bin ..= B_compressed

	bin ..= "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x52"
	bin ..= string.pack("<I4", crypto.crc32c(bin))

	return bin, hash
end

function shcc_compress_chunk_oodle(data)
	local compressed = oodle_compress(data)
	local num1 = ((#compressed & 0xFFFFFF) << 2)
	local num2 = ((#data & 0xFFFFFF) << 5)
	return string.pack("I1I1I1I1I1I1I1I1",
		0x80,
		(num1 >> 16) & 0xFF,
		(num1 >> 8) & 0xFF,
		num1 & 0xFF,
		(num2 >> 24) & 0xFF,
		(num2 >> 16) & 0xFF,
		(num2 >> 8) & 0xFF,
		(num2 & 0xF0) | 0x01 -- Ensure (byte(8) & 0x0F) == 0x01
	)..compressed
end

TYPE_DECO_OVERRIDES = 0x3
TYPE_SOUND2 = 0x4
TYPE_SOUND = 0x6
TYPE_MANIFEST = 0xD -- also used for .cvr
TYPE_BIN = 0x2B
TYPE_DEPENDANCIES_BIN = 0x52
TYPE_LUA = 0x5B
TYPE_FBX = 0x60
TYPE_LEVEL_FBX = 0x67
TYPE_TMF = 0x73
TYPE_WAV = 0x8B
TYPE_ANIM_FBX = 0x84
TYPE_PNG = 0xA3
TYPE_FX_MAT = 0xD0
TYPE_SKEL_FBX = 0x110

function download_file(path, type, b64m_hash, suffix = "")
	local url = string.format("http://content.warframe.com/0%s%s!%X_%s", suffix, path, type, b64m_hash)
	print("Downloading "..url)
	local bin, status = http.request(url)
	if status == 200 then
		--io.contents("data/tmp", bin)
		--os.execute("decompress-shcc.exe data/tmp data"..path..suffix)
		local local_path = get_local_path(path, suffix)
		io.mkdirs(io.part(local_path, "parent"))
		if bin:sub(1, 4) ~= "SHCC" then
			bin = oodle_decompress(bin, #bin * 10)
		end
		local data = shcc_decompress(bin)
		io.contents(local_path.."_H", data.H)
		if data.B then
			io.contents(local_path.."_B", data.B)
		end
		if b64m_hash ~= "---------------------w" then
			assert(b64m_hash == b64m_encode(shcc_hash(data)))
		end
	else
		print("Download failed! (HTTP "..status..")")
	end
end

function toc_decode(bin)
	local i = 1
	i += 8
	local entries = {}
	local index = 1
	while i < #bin do
		local e = {}
		e.index = index
		index += 1
		e.cache_offset, e.timestamp, e.compressed_size, e.decompressed_size, e.reserved, e.parent_index, i = string.unpack("<I8I8I4I4I4I4", bin, i)
		e.name = string.unpack("z", bin, i)
		i += 64
		entries:insert(e)
	end
	return entries
end

function toc_encode(entries)
	local buf = new buffer()
	buf:append("\x4E\xC6\x67\x18\x14\x00\x00\x00")
	for entries as e do
		buf:append(string.pack("<I8I8I4I4I4I4", e.cache_offset, e.timestamp, e.compressed_size, e.decompressed_size, e.reserved, e.parent_index))
		buf:append(e.name)
		buf:append("\0":rep(64 - #e.name))
	end
	return buf:tostring()
end

function toc_get_path(entries, index)
	if index == 0 then
		return ""
	end
	local e = entries[index]
	return toc_get_path(entries, e.parent_index).."/"..e.name
end

function toc_find_path(entries, path)
	local name = path:split("/"):back()
	for i, e in entries do
		if e.name == name and toc_get_path(entries, i) == path then
			return e
		end
	end
end

function toc_list_files(entries, index)
	local files = {}
	for entries as e do
		if e.parent_index == index then
			files:insert(e)
		end
	end
	return files
end

function cache_get_toc_entry(cache, e)
	return shcc_decompress_chunk_oodle(cache, 1 + e.cache_offset, e.decompressed_size)
end
